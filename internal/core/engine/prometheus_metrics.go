package engine

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"

	"github.com/outfitter-dev/trails/internal/protocol"
)

// PrometheusMetrics implements MetricsCollector using Prometheus metrics.
// This provides production-ready metrics with proper cardinality controls
// and integration with monitoring systems.
type PrometheusMetrics struct {
	// Command metrics
	commandCounter   *prometheus.CounterVec
	commandDuration  *prometheus.HistogramVec
	commandErrors    *prometheus.CounterVec

	// Session metrics
	activeSessions   prometheus.Gauge
	maxSessions      prometheus.Gauge
	sessionActions   *prometheus.CounterVec

	// Rate limiting metrics
	rateLimitHits    *prometheus.CounterVec

	// Event metrics
	eventCounter     *prometheus.CounterVec
	droppedEvents    *prometheus.CounterVec

	// Engine health metrics
	engineUptime     prometheus.Gauge
	workerCount      prometheus.Gauge

	// HTTP server for metrics endpoint
	server *http.Server
	port   int

	// Fallback to in-memory for snapshot compatibility
	inMemory *InMemoryMetrics
}

// NewPrometheusMetrics creates a new Prometheus metrics collector.
// The port parameter specifies where to serve the /metrics endpoint.
// Returns an error if metrics registration fails.
func NewPrometheusMetrics(port int) (*PrometheusMetrics, error) {
	// Create custom registry to avoid conflicts
	registry := prometheus.NewRegistry()

	// Command metrics
	commandCounter := prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "trails_commands_total",
			Help: "Total number of commands processed by type",
		},
		[]string{"command_type"},
	)

	commandDuration := prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "trails_command_duration_seconds",
			Help:    "Command processing duration in seconds",
			Buckets: prometheus.DefBuckets, // Standard buckets: 0.005, 0.01, 0.025, etc.
		},
		[]string{"command_type"},
	)

	commandErrors := prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "trails_command_errors_total",
			Help: "Total number of command processing errors",
		},
		[]string{"command_type", "error_type"},
	)

	// Session metrics
	activeSessions := prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "trails_sessions_active",
			Help: "Current number of active sessions",
		},
	)

	maxSessions := prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "trails_sessions_max",
			Help: "Maximum number of sessions since start",
		},
	)

	sessionActions := prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "trails_session_actions_total",
			Help: "Total number of session actions",
		},
		[]string{"action", "status"},
	)

	// Rate limiting metrics
	rateLimitHits := prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "trails_rate_limit_hits_total",
			Help: "Total number of rate limit hits",
		},
		[]string{"session_id"},
	)

	// Event metrics
	eventCounter := prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "trails_events_total",
			Help: "Total number of events generated by type",
		},
		[]string{"event_type"},
	)

	droppedEvents := prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "trails_events_dropped_total",
			Help: "Total number of dropped events due to channel saturation",
		},
		[]string{"event_type"},
	)

	// Engine health metrics
	engineUptime := prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "trails_engine_uptime_seconds",
			Help: "Engine uptime in seconds",
		},
	)

	workerCount := prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "trails_workers_active",
			Help: "Number of active command worker goroutines",
		},
	)

	// Register all metrics
	metrics := []prometheus.Collector{
		commandCounter,
		commandDuration,
		commandErrors,
		activeSessions,
		maxSessions,
		sessionActions,
		rateLimitHits,
		eventCounter,
		droppedEvents,
		engineUptime,
		workerCount,
	}

	for _, metric := range metrics {
		if err := registry.Register(metric); err != nil {
			return nil, fmt.Errorf("failed to register metric: %w", err)
		}
	}

	// Create HTTP server for metrics endpoint
	mux := http.NewServeMux()
	mux.Handle("/metrics", promhttp.HandlerFor(registry, promhttp.HandlerOpts{
		EnableOpenMetrics: true,
	}))
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("OK"))
	})

	server := &http.Server{
		Addr:         fmt.Sprintf(":%d", port),
		Handler:      mux,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
	}

	pm := &PrometheusMetrics{
		commandCounter:  commandCounter,
		commandDuration: commandDuration,
		commandErrors:   commandErrors,
		activeSessions:  activeSessions,
		maxSessions:     maxSessions,
		sessionActions:  sessionActions,
		rateLimitHits:   rateLimitHits,
		eventCounter:    eventCounter,
		droppedEvents:   droppedEvents,
		engineUptime:    engineUptime,
		workerCount:     workerCount,
		server:          server,
		port:            port,
		inMemory:        NewInMemoryMetrics(), // Fallback for snapshot compatibility
	}

	return pm, nil
}

// StartServer starts the HTTP server for the metrics endpoint.
// Returns immediately and serves metrics in a background goroutine.
// Call StopServer() to gracefully shutdown the server.
func (pm *PrometheusMetrics) StartServer(ctx context.Context) error {
	go func() {
		if err := pm.server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			// Log error but don't crash the engine
			fmt.Printf("Metrics server error: %v\n", err)
		}
	}()

	// Wait a moment to ensure server started
	time.Sleep(100 * time.Millisecond)
	return nil
}

// StopServer gracefully stops the metrics HTTP server.
func (pm *PrometheusMetrics) StopServer(ctx context.Context) error {
	if pm.server != nil {
		return pm.server.Shutdown(ctx)
	}
	return nil
}

// GetMetricsEndpoint returns the URL where metrics are served.
func (pm *PrometheusMetrics) GetMetricsEndpoint() string {
	return fmt.Sprintf("http://localhost:%d/metrics", pm.port)
}

// RecordCommand increments the command counter and updates in-memory fallback.
func (pm *PrometheusMetrics) RecordCommand(cmdType protocol.CommandType) {
	pm.commandCounter.WithLabelValues(string(cmdType)).Inc()
	pm.inMemory.RecordCommand(cmdType)
}

// RecordCommandDuration records command duration in Prometheus histogram and in-memory fallback.
func (pm *PrometheusMetrics) RecordCommandDuration(cmdType protocol.CommandType, duration time.Duration) {
	pm.commandDuration.WithLabelValues(string(cmdType)).Observe(duration.Seconds())
	pm.inMemory.RecordCommandDuration(cmdType, duration)
}

// RecordError increments the error counter and updates in-memory fallback.
func (pm *PrometheusMetrics) RecordError(operation string, err error) {
	// Try to extract command type from operation if possible
	commandType := "unknown"
	if operation == "command_processing" {
		commandType = "general"
	}
	
	pm.commandErrors.WithLabelValues(commandType, operation).Inc()
	pm.inMemory.RecordError(operation, err)
}

// RecordSessionCount updates session gauges and in-memory fallback.
func (pm *PrometheusMetrics) RecordSessionCount(count int) {
	pm.activeSessions.Set(float64(count))
	
	// For max sessions, we need to track this ourselves since Prometheus
	// gauges don't have a Get() method. We'll use a simple approach here.
	// In a full implementation, this could be tracked in the fallback metrics.
	snapshot := pm.inMemory.GetMetrics()
	if count > snapshot.MaxSessionCount {
		pm.maxSessions.Set(float64(count))
	}
	
	pm.inMemory.RecordSessionCount(count)
}

// IncrementCounter increments a named counter with tags.
func (pm *PrometheusMetrics) IncrementCounter(name string, tags map[string]string) {
	switch name {
	case "events.dropped":
		eventType := tags["type"]
		if eventType == "" {
			eventType = "unknown"
		}
		pm.droppedEvents.WithLabelValues(eventType).Inc()
		
	case "events.sent":
		eventType := tags["type"]
		if eventType == "" {
			eventType = "unknown"
		}
		pm.eventCounter.WithLabelValues(eventType).Inc()
		
	case "rate_limit.hit":
		sessionID := tags["session_id"]
		if sessionID == "" {
			sessionID = "unknown"
		}
		pm.rateLimitHits.WithLabelValues(sessionID).Inc()
		
	case "session.action":
		action := tags["action"]
		status := tags["status"]
		if action == "" {
			action = "unknown"
		}
		if status == "" {
			status = "unknown"
		}
		pm.sessionActions.WithLabelValues(action, status).Inc()
	}
	
	pm.inMemory.IncrementCounter(name, tags)
}

// UpdateEngineStats updates engine-level metrics like uptime and worker count.
func (pm *PrometheusMetrics) UpdateEngineStats(uptime time.Duration, workers int) {
	pm.engineUptime.Set(uptime.Seconds())
	pm.workerCount.Set(float64(workers))
}

// GetMetrics returns a snapshot compatible with the MetricsCollector interface.
// This delegates to the in-memory implementation for backward compatibility.
func (pm *PrometheusMetrics) GetMetrics() MetricsSnapshot {
	return pm.inMemory.GetMetrics()
}

// PrometheusConfig holds configuration for Prometheus metrics.
type PrometheusConfig struct {
	Enabled bool `json:"enabled"`
	Port    int  `json:"port"`
}

// DefaultPrometheusConfig returns sensible defaults for Prometheus metrics.
func DefaultPrometheusConfig() PrometheusConfig {
	return PrometheusConfig{
		Enabled: false, // Disabled by default for backward compatibility
		Port:    9090,  // Standard Prometheus port
	}
}